/* Auto-generated by genmsg_java.py for file /opt/ros/electric/stacks/common_msgs/visualization_msgs/msg/Marker.msg */

package ros.pkg.visualization_msgs.msg;

import java.nio.ByteBuffer;

public class Marker extends ros.communication.Message {
  static public final short ARROW = 0;
  static public final short CUBE = 1;
  static public final short SPHERE = 2;
  static public final short CYLINDER = 3;
  static public final short LINE_STRIP = 4;
  static public final short LINE_LIST = 5;
  static public final short CUBE_LIST = 6;
  static public final short SPHERE_LIST = 7;
  static public final short POINTS = 8;
  static public final short TEXT_VIEW_FACING = 9;
  static public final short MESH_RESOURCE = 10;
  static public final short TRIANGLE_LIST = 11;
  static public final short ADD = 0;
  static public final short MODIFY = 0;
  static public final short DELETE = 2;

  public ros.pkg.std_msgs.msg.Header header = new ros.pkg.std_msgs.msg.Header();
  public java.lang.String ns = new java.lang.String();
  public int id;
  public int type;
  public int action;
  public ros.pkg.geometry_msgs.msg.Pose pose = new ros.pkg.geometry_msgs.msg.Pose();
  public ros.pkg.geometry_msgs.msg.Vector3 scale = new ros.pkg.geometry_msgs.msg.Vector3();
  public ros.pkg.std_msgs.msg.ColorRGBA color = new ros.pkg.std_msgs.msg.ColorRGBA();
  public ros.communication.Duration lifetime = new ros.communication.Duration();
  public boolean frame_locked;
  public java.util.ArrayList<ros.pkg.geometry_msgs.msg.Point> points = new java.util.ArrayList<ros.pkg.geometry_msgs.msg.Point>();
  public java.util.ArrayList<ros.pkg.std_msgs.msg.ColorRGBA> colors = new java.util.ArrayList<ros.pkg.std_msgs.msg.ColorRGBA>();
  public java.lang.String text = new java.lang.String();
  public java.lang.String mesh_resource = new java.lang.String();
  public boolean mesh_use_embedded_materials;

  public Marker() {
  }

  public static java.lang.String __s_getDataType() { return "visualization_msgs/Marker"; }
  public java.lang.String getDataType() { return __s_getDataType(); }
  public static java.lang.String __s_getMD5Sum() { return "18326976df9d29249efc939e00342cde"; }
  public java.lang.String getMD5Sum() { return __s_getMD5Sum(); }
  public static java.lang.String __s_getMessageDefinition() { return "# See http://www.ros.org/wiki/rviz/DisplayTypes/Marker and http://www.ros.org/wiki/rviz/Tutorials/Markers%3A%20Basic%20Shapes for more information on using this message with rviz\n" +
"\n" +
"uint8 ARROW=0\n" +
"uint8 CUBE=1\n" +
"uint8 SPHERE=2\n" +
"uint8 CYLINDER=3\n" +
"uint8 LINE_STRIP=4\n" +
"uint8 LINE_LIST=5\n" +
"uint8 CUBE_LIST=6\n" +
"uint8 SPHERE_LIST=7\n" +
"uint8 POINTS=8\n" +
"uint8 TEXT_VIEW_FACING=9\n" +
"uint8 MESH_RESOURCE=10\n" +
"uint8 TRIANGLE_LIST=11\n" +
"\n" +
"uint8 ADD=0\n" +
"uint8 MODIFY=0\n" +
"uint8 DELETE=2\n" +
"\n" +
"Header header                        # header for time/frame information\n" +
"string ns                            # Namespace to place this object in... used in conjunction with id to create a unique name for the object\n" +
"int32 id 		                         # object ID useful in conjunction with the namespace for manipulating and deleting the object later\n" +
"int32 type 		                       # Type of object\n" +
"int32 action 	                       # 0 add/modify an object, 1 (deprecated), 2 deletes an object\n" +
"geometry_msgs/Pose pose                 # Pose of the object\n" +
"geometry_msgs/Vector3 scale             # Scale of the object 1,1,1 means default (usually 1 meter square)\n" +
"std_msgs/ColorRGBA color             # Color [0.0-1.0]\n" +
"duration lifetime                    # How long the object should last before being automatically deleted.  0 means forever\n" +
"bool frame_locked                    # If this marker should be frame-locked, i.e. retransformed into its frame every timestep\n" +
"\n" +
"#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)\n" +
"geometry_msgs/Point[] points\n" +
"#Only used if the type specified has some use for them (eg. POINTS, LINE_STRIP, ...)\n" +
"#number of colors must either be 0 or equal to the number of points\n" +
"#NOTE: alpha is not yet used\n" +
"std_msgs/ColorRGBA[] colors\n" +
"\n" +
"# NOTE: only used for text markers\n" +
"string text\n" +
"\n" +
"# NOTE: only used for MESH_RESOURCE markers\n" +
"string mesh_resource\n" +
"bool mesh_use_embedded_materials\n" +
"\n" +
"================================================================================\n" +
"MSG: std_msgs/Header\n" +
"# Standard metadata for higher-level stamped data types.\n" +
"# This is generally used to communicate timestamped data \n" +
"# in a particular coordinate frame.\n" +
"# \n" +
"# sequence ID: consecutively increasing ID \n" +
"uint32 seq\n" +
"#Two-integer timestamp that is expressed as:\n" +
"# * stamp.secs: seconds (stamp_secs) since epoch\n" +
"# * stamp.nsecs: nanoseconds since stamp_secs\n" +
"# time-handling sugar is provided by the client library\n" +
"time stamp\n" +
"#Frame this data is associated with\n" +
"# 0: no frame\n" +
"# 1: global frame\n" +
"string frame_id\n" +
"\n" +
"================================================================================\n" +
"MSG: geometry_msgs/Pose\n" +
"# A representation of pose in free space, composed of postion and orientation. \n" +
"Point position\n" +
"Quaternion orientation\n" +
"\n" +
"================================================================================\n" +
"MSG: geometry_msgs/Point\n" +
"# This contains the position of a point in free space\n" +
"float64 x\n" +
"float64 y\n" +
"float64 z\n" +
"\n" +
"================================================================================\n" +
"MSG: geometry_msgs/Quaternion\n" +
"# This represents an orientation in free space in quaternion form.\n" +
"\n" +
"float64 x\n" +
"float64 y\n" +
"float64 z\n" +
"float64 w\n" +
"\n" +
"================================================================================\n" +
"MSG: geometry_msgs/Vector3\n" +
"# This represents a vector in free space. \n" +
"\n" +
"float64 x\n" +
"float64 y\n" +
"float64 z\n" +
"================================================================================\n" +
"MSG: std_msgs/ColorRGBA\n" +
"float32 r\n" +
"float32 g\n" +
"float32 b\n" +
"float32 a\n" +
"\n" +
""; }
  public java.lang.String getMessageDefinition() { return __s_getMessageDefinition(); }

  public Marker clone() {
    Marker c = new Marker();
    c.deserialize(serialize(0));
    return c;
  }

  public void setTo(ros.communication.Message m) {
    deserialize(m.serialize(0));
  }

  public int serializationLength() {
    int __l = 0;
    __l += header.serializationLength();
    __l += 4 + ns.length();
    __l += 4; // id
    __l += 4; // type
    __l += 4; // action
    __l += pose.serializationLength();
    __l += scale.serializationLength();
    __l += color.serializationLength();
    __l += 8; // lifetime
    __l += 1; // frame_locked
    __l += 4;
    for(ros.pkg.geometry_msgs.msg.Point val : points) {
      __l += val.serializationLength();
    }
    __l += 4;
    for(ros.pkg.std_msgs.msg.ColorRGBA val : colors) {
      __l += val.serializationLength();
    }
    __l += 4 + text.length();
    __l += 4 + mesh_resource.length();
    __l += 1; // mesh_use_embedded_materials
    return __l;
  }

  public void serialize(ByteBuffer bb, int seq) {
    header.serialize(bb, seq);
    Serialization.writeString(bb, ns);
    bb.putInt(id);
    bb.putInt(type);
    bb.putInt(action);
    pose.serialize(bb, seq);
    scale.serialize(bb, seq);
    color.serialize(bb, seq);
    Serialization.writeDuration(bb, lifetime);
    bb.put((byte)(frame_locked ? 1 : 0));
    bb.putInt(points.size());
    for(ros.pkg.geometry_msgs.msg.Point val : points) {
      val.serialize(bb, seq);
    }
    bb.putInt(colors.size());
    for(ros.pkg.std_msgs.msg.ColorRGBA val : colors) {
      val.serialize(bb, seq);
    }
    Serialization.writeString(bb, text);
    Serialization.writeString(bb, mesh_resource);
    bb.put((byte)(mesh_use_embedded_materials ? 1 : 0));
  }

  public void deserialize(ByteBuffer bb) {
    header.deserialize(bb);
    ns = Serialization.readString(bb);
    id = bb.getInt();
    type = bb.getInt();
    action = bb.getInt();
    pose.deserialize(bb);
    scale.deserialize(bb);
    color.deserialize(bb);
    lifetime = Serialization.readDuration(bb);
    frame_locked = bb.get() != 0 ? true : false;

    int __points_len = bb.getInt();
    points = new java.util.ArrayList<ros.pkg.geometry_msgs.msg.Point>(__points_len);
    for(int __i=0; __i<__points_len; __i++) {
      ros.pkg.geometry_msgs.msg.Point __tmp = new ros.pkg.geometry_msgs.msg.Point();
      __tmp.deserialize(bb);
      points.add(__tmp);;
    }

    int __colors_len = bb.getInt();
    colors = new java.util.ArrayList<ros.pkg.std_msgs.msg.ColorRGBA>(__colors_len);
    for(int __i=0; __i<__colors_len; __i++) {
      ros.pkg.std_msgs.msg.ColorRGBA __tmp = new ros.pkg.std_msgs.msg.ColorRGBA();
      __tmp.deserialize(bb);
      colors.add(__tmp);;
    }
    text = Serialization.readString(bb);
    mesh_resource = Serialization.readString(bb);
    mesh_use_embedded_materials = bb.get() != 0 ? true : false;
  }

  @SuppressWarnings("all")
  public boolean equals(Object o) {
    if(!(o instanceof Marker))
      return false;
    Marker other = (Marker) o;
    return
      header.equals(other.header) &&
      ns.equals(other.ns) &&
      id == other.id &&
      type == other.type &&
      action == other.action &&
      pose.equals(other.pose) &&
      scale.equals(other.scale) &&
      color.equals(other.color) &&
      lifetime.equals(other.lifetime) &&
      frame_locked == other.frame_locked &&
      points.equals(other.points) &&
      colors.equals(other.colors) &&
      text.equals(other.text) &&
      mesh_resource.equals(other.mesh_resource) &&
      mesh_use_embedded_materials == other.mesh_use_embedded_materials &&
      true;
  }

  @SuppressWarnings("all")
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    long tmp;
    result = prime * result + (this.header == null ? 0 : this.header.hashCode());
    result = prime * result + (this.ns == null ? 0 : this.ns.hashCode());
    result = prime * result + this.id;
    result = prime * result + this.type;
    result = prime * result + this.action;
    result = prime * result + (this.pose == null ? 0 : this.pose.hashCode());
    result = prime * result + (this.scale == null ? 0 : this.scale.hashCode());
    result = prime * result + (this.color == null ? 0 : this.color.hashCode());
    result = prime * result + (this.lifetime == null ? 0 : this.lifetime.hashCode());
    result = prime * result + (this.frame_locked ? 1231 : 1237);
    result = prime * result + (this.points == null ? 0 : this.points.hashCode());
    result = prime * result + (this.colors == null ? 0 : this.colors.hashCode());
    result = prime * result + (this.text == null ? 0 : this.text.hashCode());
    result = prime * result + (this.mesh_resource == null ? 0 : this.mesh_resource.hashCode());
    result = prime * result + (this.mesh_use_embedded_materials ? 1231 : 1237);
    return result;
  }
} // class Marker

